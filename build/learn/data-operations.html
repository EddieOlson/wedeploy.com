<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Launchpad Project (Beta)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<link rel="shortcut icon" href="/images/favicon.ico">

	<!-- Fonts -->
	<script src="https://use.typekit.net/kkw4zdf.js"></script>
	<script>try{Typekit.load({ async: true });}catch(e){}</script>
	<link rel="stylesheet" href="/vendor/fonts/icon-12.css">
	<link rel="stylesheet" href="/vendor/fonts/icon-16.css">
	<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:700,400,300">

	<!-- Styles -->
	<link rel="stylesheet" href="/styles/all.css">
	
	<link rel="stylesheet" href="/styles/learn.css">
	<link rel="stylesheet" href="/vendor/styles/github.css">

</head>
<body class="fade-out">

	
	<nav class="topbar topbar-inverse">
		<div class="topbar-logo">
			<a class="topbar-logo-link" href="/">
				<span class="icon-16-launchpad-logo"></span>
				<span class="topbar-logo-text">Launchpad <span class="topbar-logo-complementary">Project <span class="topbar-logo-label">Beta</span></span></span>
			</a>
		</div>
		<ul class="topbar-list">
			<li class="topbar-item">
				<a class="topbar-link" href="/">Product</a>
			</li>
			<li class="topbar-item">
				<a class="topbar-link topbar-link-selected" href="/learn">Learn</a>
			</li>
			<li class="topbar-item">
				<a class="topbar-link" href="/dashboard/login/signin">Login</a>
			</li>
		</ul>
	</nav>

	<main class="docs">
		<div class="container">
			<div class="row">
				<nav class="docs-nav col-xs-12 col-sm-3">
					<p class="docs-nav-group">What is?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="/learn" class="docs-nav-link">Frequently Asked Questions</a>
						</li>
					</ul>

					<p class="docs-nav-group">How to use?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="/learn/authentication.html" class="docs-nav-link">Authentication</a>
						</li>
						<li class="docs-nav-item">
							<a href="/learn/realtime-database.html" class="docs-nav-link">Realtime Database</a>
						</li>
						<li class="docs-nav-item">
							<a href="/learn/custom-apis.html" class="docs-nav-link">Custom APIs</a>
						</li>
					</ul>

					<p class="docs-nav-group">How it works?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="/learn/data-operations.html" class="docs-nav-link">Data Operations</a>
						</li>
					</ul>
				</nav>

				<article class="docs-content col-xs-12 col-sm-6 col-sm-offset-1">
					<h1 id="data-operations">Data Operations</h1>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#basic-concepts">Basic Concepts</a></li>
<li><a href="#write-operations">Write Operations</a></li>
<li><a href="#read-operations">Read Operations</a></li>
<li><a href="#query">Query</a></li>
<li><a href="#basic-filters">Basic Filters</a></li>
<li><a href="#text-filters">Text Filters</a></li>
<li><a href="#geo-location-filters">Geo Location Filters</a></li>
<li><a href="#data-aggregation">Data Aggregation</a></li>
<li><a href="#sort-limit-and-offset">Sort, Limit, and Offset</a></li>
</ul>
<h2 id="basic-concepts">Basic Concepts</h2>
<p>We offer a built-in JSON-like datastore for all application services, with a RESTful interface that can be easily plugged to you api as follows:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;@/*&quot;
  }
]
</code></pre>
<p>This is the easiest way to provide all data functionalities to your service. With the token <code>@</code> we can map the following path <code>/*</code> to be used to access the datastore directly.</p>
<p>This integration with the <code>api.json</code> configuration gives you power to filter which data functionalities you want to enable to your service. For example, if you want to enable only access to a collection named movies, and only to push and read data, you can map a path as follows:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;/my/data/path/@/movies/*&quot;,
    &quot;method&quot;:[&quot;GET&quot;,&quot;POST&quot;]
  }
]
</code></pre>
<p>Note that you data doesn&#39;t need to be rooted, you can mount your data path anywhere you want, just like we did in the example above. But even if you mount the same data path more than once, it refers to the same resource:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;@/*&quot;
  },
  {
    &quot;path&quot;:&quot;/my/alias/@/movies/*&quot;
  }
]
</code></pre>
<p>In this case, requests to both <code>curl &#39;https://liferay.io/app/service/movies&#39;</code> and <code>curl &#39;https://liferay.io/app/service/my/alias/movies&#39;</code> will access the same movies collection.</p>
<p>Now we can see how easy and powerful it is to integrate the data with all functionalities we offer in <a href="https://github.com/liferay-apps/landing/wiki/How-To-Use#custom_apis">Custom API&#39;s</a>. For example, to create a collection of users where anyone can read all users, but one can only write its own data, we can use the following code:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;/data/@/users/:id/*&quot;,
    &quot;method&quot;:[&quot;PUT&quot;,&quot;PATCH&quot;,&quot;DELETE&quot;],
    &quot;auth&quot;:{
      &quot;validator&quot;:&quot;$auth.id === $params.id&quot;
    }
  },
  {
    &quot;path&quot;:&quot;/data/@/users/*&quot;,
    &quot;method&quot;:&quot;GET&quot;
  }
]
</code></pre>
<h4 id="data-types">Data types</h4>
<p>While mapping our data paths, there is one special path that can be used for datastore configuration: the root data path. We can mount it in a special place, if we want, to manage our collections and field mappings like this:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;/admin/data/@/&quot;
  }
]
</code></pre>
<p>Or, if we want to keep things simple, we can just use the first mapping we created:</p>
<pre><code class="lang-json">[
  {
    &quot;path&quot;:&quot;@/*&quot;
  }
]
</code></pre>
<p>And use our service root for that. If we get this root data path we will receive all collections and mappings we have configured in our datastore, which initially is an empty list:</p>
<pre><code class="lang-json">[]
</code></pre>
<p>This data will be filled dynamically while new documents are added to our datastore. For example, to load information from the movies and places collections we used in our <a href="https://github.com/liferay-apps/landing/wiki/How-To-Use#realtime_data">Realtime Data</a> page:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/service&quot;
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service&#39;).get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service&quot;).get();
</code></pre>
<p>We will receive the following configuration from our service:</p>
<pre><code class="lang-json">[
    {
        &quot;movies&quot;: {
            &quot;year&quot;: &quot;long&quot;,
            &quot;rating&quot;: &quot;double&quot;,
            &quot;title&quot;: &quot;string&quot;
        }
    },
    {
        &quot;places&quot;: {
            &quot;category&quot;: &quot;string&quot;,
            &quot;location&quot;: &quot;geo_point&quot;,
            &quot;name&quot;: &quot;string&quot;
        }
    }
]
</code></pre>
<p>This datatype mapping for collection fields can be created dynamically, when the type of a field is extracted from the first JSON document we put in a new collection, or manually using POST and PATCH methods. With this endpoint we can add new collections via POST:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;POST&quot; &quot;http://liferay.io/app/service&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;books\&quot;:{\&quot;title\&quot;:\&quot;string\&quot;,\&quot;published\&quot;:\&quot;date\&quot;}}&quot;
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service&#39;)
   .post({books:{title:&quot;string&quot;,published:&quot;date&quot;}})
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Map books = new HashMap();
Map fields = new HashMap();
fields.put(&quot;title&quot;, &quot;string&quot;);
fields.put(&quot;published&quot;, &quot;date&quot;);
books.put(&quot;books&quot;, fields);

Launchpad.url(&quot;http://liferay.io/app/service&quot;)
   .post(books);
</code></pre>
<p>Or update existing ones by adding new field mappings:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PATCH&quot; &quot;http://liferay.io/app/service&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;books\&quot;:{\&quot;author\&quot;:\&quot;string\&quot;}}&quot;
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service&#39;)
   .patch({books:{author:&quot;string&quot;}})
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Map books = new HashMap();
Map fields = new HashMap();
fields.put(&quot;author&quot;, &quot;string&quot;);
books.put(&quot;books&quot;, fields);

Launchpad.url(&quot;http://liferay.io/app/service&quot;)
   .patch(books);
</code></pre>
<p>There is no support now for updating the datatype of an existing field. We support basic JSON types:</p>
<ul>
<li>string</li>
<li>long</li>
<li>integer</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
</ul>
<p>And special types that can be created from string or object values:</p>
<ul>
<li>date - we use <a href="http://www.joda.org/">Joda</a>&#39;s <a href="http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateOptionalTimeParser(">optional date format</a>)</li>
<li>geo_point - can be specified as <code>&quot;lat,lon&quot;</code>, <code>{ &#39;lat&#39;: lat, &#39;lon&#39;: lon }</code> or <code>[lon,lat]</code></li>
<li>geo_shape - we use <a href="http://geojson.org/">GeoJSON</a> format</li>
</ul>
<p>As these special types cannot be inferred from a JSON, we need to manually set the field type to use one before it is dynamically created. The array is supported by default in any field, restricted to be an array os elements of the same mapped type. The object type is also supported, and is mapped naturally:</p>
<pre><code class="lang-json">{
  &quot;movies&quot;:{
    &quot;screenings&quot;: {
      &quot;name&quot;:&quot;string&quot;,
      &quot;location&quot;:&quot;geo_point&quot;,
      &quot;time&quot;: &quot;date&quot;
    }
  }
}
</code></pre>
<p>And then we can create a movie like:</p>
<pre><code class="lang-json">{
  &quot;title&quot;: &quot;Spectre&quot;,
  &quot;year&quot;: 2015,
  &quot;screenings&quot;:[
    {
      &quot;name&quot;: &quot;BFI IMAX&quot;,
      &quot;location&quot;: &quot;51.524894,-0.0867715&quot;,
      &quot;time&quot;: &quot;2015-10-07T17:00&quot;
    },
    {
      &quot;name&quot;: &quot;Vue Cinemas&quot;,
      &quot;location&quot;: &quot;51.5089728,-0.1343197&quot;,
      &quot;time&quot;: &quot;2015-10-07T19:30&quot;
    }
  ]
}
</code></pre>
<h2 id="write-operations">Write Operations</h2>
<p>All data write operations are mapped to a HTTP method:</p>
<ul>
<li>DELETE: removes a field, document, collection data and mapping</li>
</ul>
<h2 id="read-operations">Read Operations</h2>
<h2 id="query">Query</h2>
<p>Query is the basic entity for data search and has the following components:</p>
<ul>
<li>filter</li>
<li>search</li>
<li>aggregation</li>
<li>highlight</li>
<li>sort</li>
<li>limit</li>
<li>offset</li>
</ul>
<h2 id="basic-filters">Basic Filters</h2>
<p>Filter is a list of inner filters:</p>
<pre><code class="lang-json">[
  { &quot;filter1&quot; },
  { &quot;filter2&quot; }
]
</code></pre>
<p>In this example, all filters are composed with the <code>AND</code> operator:</p>
<pre><code>filter = filter1 AND filter2 AND...
</code></pre><p>If a list contains just one predicate, the list may be omitted, and only the<br>predicate can be sent instead.</p>
<h4 id="conjunction">Conjunction</h4>
<p>The <code>and</code> key is used for Conjunction operations, shown in the following example:</p>
<p>JSON</p>
<pre><code class="lang-json">{
  &quot;and&quot;: [
    { &quot;filter1&quot; },
    { &quot;filter2&quot; }
  ]
}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">filter1.and(filter2)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">filter1.and(filter2)
</code></pre>
<p>This query is equivalent to the previous example.</p>
<h4 id="disjunction">Disjunction</h4>
<p>The <code>or</code> key is used for Disjunction operations, shown in the code below:</p>
<p>JSON</p>
<pre><code class="lang-json">{
  &quot;or&quot;: [
    { &quot;filter1&quot; },
    { &quot;filter2&quot; }
  ]
}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">filter1.or(filter2)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">filter1.or(filter2)
</code></pre>
<h4 id="negation">Negation</h4>
<p>The <code>not</code> key is used for Negation operations, shown in the example below:</p>
<p>JSON</p>
<pre><code class="lang-json">{
  &quot;not&quot;: { &quot;filter1&quot; }
}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Filter.not(filter1)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Filter.not(filter1)
</code></pre>
<h4 id="filter-predicate">Filter predicate</h4>
<p>A filter predicate is defined over a document field. A basic filter predicate is defined with <em>name</em>, <em>value</em>, and <em>operator</em>, shown in the following code:</p>
<p>JSON</p>
<pre><code class="lang-json">{
  &quot;fieldName&quot; : {
    &quot;operator&quot; : &quot;operator&quot;,
    &quot;value&quot; : &quot;data&quot;
  }
}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Filter.field(&#39;fieldName&#39;, &#39;operator&#39;, data)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Filter.field(&quot;fieldName&quot;, &quot;operator&quot;, data)
</code></pre>
<p>The basic SQL-like operators are the following predefined names:</p>
<p>JSON</p>
<pre><code class="lang-json">{&quot;age&quot;:{&quot;operator&quot;:&quot;&gt;&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;&gt;=&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;&lt;&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;&lt;=&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;=&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;!=&quot;,&quot;value&quot;:25}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;any&quot;,&quot;value&quot;:[24,25,26]}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;none&quot;,&quot;value&quot;:[24,25,26]}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;~&quot;,&quot;value&quot;:&quot;J.* Smith&quot;}}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">// operator = &#39;&lt;&#39;
Filter.lt(&#39;age&#39;, 25)

// operator = &#39;&lt;=&#39;
Filter.lte(&#39;age&#39;, 25)

// operator = &#39;&gt;&#39;
Filter.gt(&#39;age&#39;, 25)

// operator = &#39;&gt;=&#39;
Filter.gte(&#39;age&#39;, 25)

// operator = &#39;=&#39;
Filter.equal(&#39;age&#39;, 25)

// operator = &#39;!=&#39; 
Filter.notEqual(&#39;age&#39;, 25)

// operator = &#39;any&#39;
Filter.any(&#39;age&#39;, 24, 25, 26)

// operator = &#39;none&#39; 
Filter.none(&#39;age&#39;, 24, 25, 26)

// operator = &#39;~&#39;
Filter.regex(&#39;name&#39;, &#39;J.* Smith&#39;)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">// operator = &quot;&lt;&quot;
Filter.lt(&quot;age&quot;, 25)

// operator = &quot;&lt;=&quot;
Filter.lte(&quot;age&quot;, 25)

// operator = &quot;&gt;&quot;
Filter.gt(&quot;age&quot;, 25)

// operator = &quot;&gt;=&quot;
Filter.gte(&quot;age&quot;, 25)

// operator = &quot;=&quot;
Filter.equal(&quot;age&quot;, 25)

// operator = &quot;!=&quot; 
Filter.notEqual(&quot;age&quot;, 25)

// operator = &quot;any&quot;
Filter.any(&quot;age&quot;, 24, 25, 26)

// operator = &quot;none&quot; 
Filter.none(&quot;age&quot;, 24, 25, 26)

// operator = &quot;~&quot;
Filter.regex(&quot;name&quot;, &quot;J.* Smith&quot;)
</code></pre>
<p>Other basic operators that we support are <code>exists</code>, <code>missing</code>, and <code>range</code>, shown in the following code examples:</p>
<p>JSON</p>
<pre><code class="lang-json">{&quot;age&quot;:{&quot;operator&quot;:&quot;exists&quot;}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;missing&quot;}}

{&quot;age&quot;:{&quot;operator&quot;:&quot;range&quot;,&quot;value&quot;:{&quot;from&quot;:20,&quot;to&quot;:30}}}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">// operator = &#39;exists&#39;
Filter.exists(&#39;age&#39;)

// operator = &#39;missing&#39;
Filter.missing(&#39;age&#39;)

// operator = &#39;range&#39;
Filter.range(&#39;age&#39;, 20, 30)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">// operator = &quot;exists&quot;
Filter.exists(&quot;age&quot;)

// operator = &quot;missing&quot;
Filter.missing(&quot;age&quot;)

// operator = &quot;range&quot;
Filter.range(&quot;age&quot;, 20, 30)
</code></pre>
<h4 id="short-form-of-filter-predicate-special-case-">Short form of filter predicate (special case)</h4>
<p>When using the common <code>=</code> operator, filter predicate can be written in<br>short form using the following syntax:</p>
<p>JSON</p>
<pre><code class="lang-json">{
   &quot;fieldName&quot; : &quot;value&quot;
}
</code></pre>
<p>Javascript</p>
<pre><code class="lang-js">Filter.field(&#39;fieldName&#39;, value)
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Filter.field(&quot;fieldName&quot;, value)
</code></pre>

				</article>
			</div>
		</div>
	</main>


	<script src="/scripts/all.js"></script>
	
	<script src="/scripts/learn.js"></script>
	<script src="/vendor/scripts/highlight.pack.min.js"></script>


	<!-- Intercom -->
	<script>
	window.intercomSettings = { app_id: 'ytqx30hx' };
	(function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',intercomSettings);}else{var d=document;var i=function(){i.c(arguments)};i.q=[];i.c=function(args){i.q.push(args)};w.Intercom=i;function l(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/ytqx30hx';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);}if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})()
	</script>

	<!-- Analytics -->
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-37033501-2', 'auto');
	ga('send', 'pageview');
	</script>

	<!-- Inspectlet -->
	<script id="inspectletjs">
	window.__insp = window.__insp || [];
	__insp.push(['wid', 1029478452]);
	(function() {
		function ldinsp(){var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); };
		document.readyState != "complete" ? (window.attachEvent ? window.attachEvent('onload', ldinsp) : window.addEventListener('load', ldinsp, false)) : ldinsp();
	})();
	</script>
</body>
</html>