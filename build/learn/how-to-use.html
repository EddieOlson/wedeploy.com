<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Launchpad Project (Beta)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<link rel="shortcut icon" href="/images/favicon.ico">

	<!-- Fonts -->
	<script src="https://use.typekit.net/kkw4zdf.js"></script>
	<script>try{Typekit.load({ async: true });}catch(e){}</script>
	<link rel="stylesheet" href="/vendor/fonts/icon-12.css">
	<link rel="stylesheet" href="/vendor/fonts/icon-16.css">
	<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:700,400,300">

	<!-- Styles -->
	<link rel="stylesheet" href="/styles/all.css">
	
	<link rel="stylesheet" href="/vendor/styles/codemirror.css">
	<link rel="stylesheet" href="/vendor/styles/mdn-like.css">
	<link rel="stylesheet" href="/styles/docs.css">

</head>
<body class="fade-out">

	
	<nav class="topbar topbar-inverse">
		<div class="topbar-logo">
			<a class="topbar-logo-link" href="/">
				<span class="icon-16-launchpad-logo"></span>
				<span class="topbar-logo-text">Launchpad <span class="topbar-logo-complementary">Project <span class="topbar-logo-label">Beta</span></span></span>
			</a>
		</div>
		<ul class="topbar-list">
			<li class="topbar-item">
				<a class="topbar-link" href="/">Product</a>
			</li>
			<li class="topbar-item">
				<a class="topbar-link topbar-link-selected" href="/learn">Learn</a>
			</li>
			<li class="topbar-item">
				<a class="topbar-link" href="/dashboard/login/signin">Login</a>
			</li>
		</ul>
	</nav>

	<main class="docs">
		<div class="container">
			<div class="row">
				<nav class="docs-nav col-xs-12 col-sm-3">
					<p class="docs-nav-group">What is?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
					</ul>

					<p class="docs-nav-group">How it works?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
					</ul>

					<p class="docs-nav-group">How to use?</p>
					<ul class="docs-nav-list">
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
						<li class="docs-nav-item">
							<a href="#" class="docs-nav-link">Lorem ipsum dolor sit</a>
						</li>
					</ul>
				</nav>

				<article class="docs-content col-xs-12 col-sm-6 col-sm-offset-1">
					<h2 id="contents">Contents</h2>
<ol>
<li><a href="#authentication"> Authentication </a></li>
<li><a href="#realtime_database"> Realtime Database </a></li>
<li><a href="#custom_apis"> Custom APIs </a></li>
</ol>
<p><a name="authentication" /></p>
<h2 id="authentication">Authentication</h2>
<p>With Launchpad, you can authenticate users from our Java, Swift, and JavaScript SDKs in just a few lines of code. We have built-in functionality for authenticating users using their email and password. Apps that use Launchpad built-in auth services can handle user login entirely with client-side code, saving you time and the headache of operating your own back-end.</p>
<p>The following sections explain authentication in greater detail:</p>
<ol>
<li><a href="#authentication_configuration">Authentication Configuration</a></li>
<li><a href="#authentication_provider">Authentication Provider</a></li>
<li><a href="#authentication_loggin_users_in">Logging Users In</a></li>
<li><a href="#authentication_loggin_users_out">Logging Users Out</a></li>
</ol>
<p><a name="authentication_configuration" /></p>
<h3 id="1-authentication-configuration">1. Authentication Configuration</h3>
<p>Launchpad provides an authentication service out-of-the-box for any newly created app. To facilitate your authentication needs, Launchpad provides some extended configuration options, such as login and redirect URL properties. To set extended configuration options for your app, you just need to create an <code>auth.json</code> file in your application&#39;s root folder.</p>
<p>For example, the following code shows an <code>auth.json</code> file with its default values:</p>
<pre><code class="lang-js">{
    &quot;auth.hashAlgorithm&quot;: null, // &quot;bcrypt&quot;, &quot;pbkdf2&quot;
    &quot;auth.loginPageUrl&quot;: null,
    &quot;auth.loginRedirectUrl&quot;: null,
    &quot;auth.loginUrl&quot;: &quot;/login&quot;,
    &quot;auth.logoutRedirectUrl&quot;: null,
    &quot;auth.logoutUrl&quot;: &quot;/logout&quot;,
    &quot;auth.passwordParam&quot;: &quot;password&quot;,
    &quot;auth.permissionsParam&quot;: &quot;permissions&quot;,
    &quot;auth.realm&quot;: &quot;rest&quot;,
    &quot;auth.realmRestUrl&quot;: &quot;/users/data&quot;,
    &quot;auth.roles&quot;: {},
    &quot;auth.rolesParam&quot;: &quot;roles&quot;,
    &quot;auth.tokenParam&quot;: &quot;token&quot;,
    &quot;auth.userParam&quot;: &quot;email&quot;
}
</code></pre>
<p>The developer preview version of Launchpad allows you to configure your application&#39;s authentication in your local development environment.</p>
<p><a name="authentication_provider" /></p>
<h3 id="2-authentication-provider">2. Authentication Provider</h3>
<p>The user&#39;s identity allows an app to provide a customized experience and grant them permissions to access their APIs. The process of proving a user&#39;s identity is called authentication. The default authentication provider of a Launchpad application is known as the user service. The user service provides a RESTful API to save, update, and delete users. The app uses the user service stored data to fulfill the default authentication provider.</p>
<p>In the <a href="#authentication_configuration">Authentication Configuration</a> section, important configuration properties were introduced, including <code>auth.userParam</code>, <code>auth.passwordParam</code>, and <code>auth.realmRestUrl</code>. Launchpad uses this information to interact with the user service API. As an example, let&#39;s use the app you have created called <code>App</code>. Every app has it&#39;s own URL, in this case <a href="http://liferay.io/app">http://liferay.io/app</a>. The user service will be available under <a href="http://liferay.io/app/users">http://liferay.io/app/users</a>.</p>
<p>Saving a new user is as simple as performing a POST request with the proper user and password parameter names, e.g.</p>
<pre><code class="lang-bash">curl -X &quot;POST&quot; &quot;http://liferay.io/app/users/data&quot; \
    --data-urlencode &quot;email=user@liferay.io&quot; \
    --data-urlencode &quot;password=pass&quot; \
    --data-urlencode &quot;foo=bar&quot;
</code></pre>
<p>The request will respond with the user document created:</p>
<pre><code class="lang-js">{&quot;password&quot;:&quot;pass&quot;,&quot;id&quot;:&quot;115992383516607958&quot;,&quot;email&quot;:&quot;user@liferay.io&quot;,&quot;foo&quot;:&quot;bar&quot;}
</code></pre>
<p>To retrieve the users, an authenticated GET request can be performed, e.g.</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/users/data&quot; \
    -H &quot;Authorization: Basic dXNlckBsaWZlcmF5LmlvOnBhc3M=&quot; \
</code></pre>
<p>The request will respond with the list of users:</p>
<pre><code class="lang-js">[{&quot;password&quot;:&quot;pass&quot;,&quot;id&quot;:&quot;115992383516607958&quot;,&quot;email&quot;:&quot;user@liferay.io&quot;,&quot;foo&quot;:&quot;bar&quot;}]
</code></pre>
<p>To delete an user, an authenticated DELETE request can be performed, e.g.</p>
<pre><code class="lang-bash">curl -X &quot;DELETE&quot; &quot;http://liferay.io/app/users/data/115992383516607958&quot; \
    -H &quot;Authorization: Basic dXNlckBsaWZlcmF5LmlvOnBhc3M=&quot; \
</code></pre>
<p><a name="authentication_loggin_users_in" /></p>
<h3 id="3-logging-users-in">3. Logging Users In</h3>
<p>Now you know how to save, retrieve, and delete users in your application. The user data stored will be used by the auth provider to lookup user emails and passwords to authenticate. </p>
<p>Launchpad supports the following authentication types:</p>
<h4 id="-basic-"><code>Basic</code></h4>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/private&quot; \
    -H &quot;Authorization: Basic dXNlckBsaWZlcmF5LmlvOnBhc3M=&quot; \
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/private&#39;)
   .auth(&#39;user@liferay.io&#39;, &#39;pass&#39;)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/private&quot;)
   .auth(&quot;user@liferay.io&quot;, &quot;pass&quot;)
   .get();
</code></pre>
<h4 id="-token-"><code>Token</code></h4>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/private&quot; \
    -H &quot;Authorization: Bearer [token]&quot; \
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/private&#39;)
   .auth(&#39;[token]&#39;)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/private&quot;)
   .auth(&quot;[token]&quot;)
   .get();
</code></pre>
<h4 id="-cookie-"><code>Cookie</code></h4>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/private&quot; \
    -H &quot;Cookie: token=[token]&quot; \
</code></pre>
<h4 id="-form-"><code>Form</code></h4>
<p>Launchpad&#39;s Form login is very handy when building web applications. Launchpad uses the configuration <code>auth.loginUrl</code> to handle the login request and the <code>auth.loginRedirectUrl</code> to automatically redirect when a login is successful. The Form login is demonstrated in the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;POST&quot; &quot;http://liferay.io/app/login&quot; \
    --data-urlencode &quot;email=user@liferay.io&quot; \
    --data-urlencode &quot;password=pass&quot; \
</code></pre>
<p>Currently, Launchpad provides the authentication token using the response header <code>Set-Cookie: token=[token]</code>. This allows cookie enabled clients to keep the login session using cookies.</p>
<p><a name="authentication_loggin_users_out" /></p>
<h3 id="4-logging-users-out">4. Logging Users Out</h3>
<p>Performing a GET request on the URL configured on <code>auth.logoutUrl</code> logs the user out. The <code>auth.loginPageUrl</code> will automatically redirect to the login page after logout. The following example shows how to perform a GET request on the logout URL:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/logout&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/logout&#39;).get();
</code></pre>
<p>Java</p>
<pre><code class="lang-js">Launchpad.url(&quot;http://liferay.io/app/logout&quot;).get();
</code></pre>
<p><a name="realtime_database" /></p>
<h2 id="realtime-database">Realtime Database</h2>
<p>Launchpad provides a JSON document storage with search and realtime capabilities to all application services, with no need of extra server-side code. Read and write operations are translated into a RESTful API. The Launchpad client also helps you to easily create complex queries in Java, Javascript, or Swift, and search your data in realtime.</p>
<p>The following sections explain how to use your datastore in more detail:</p>
<ol>
<li><a href="#realtime_database_write_data">Write Data</a></li>
<li><a href="#realtime_database_read_data">Read Data</a></li>
<li><a href="#realtime_database_search_data_in_realtime">Search Data in Realtime</a></li>
</ol>
<p><a name="realtime_database_write_data" /></p>
<h3 id="1-write-data">1. Write Data</h3>
<p>Writing new data is as simple as posting in a URL. The following example post data for a movie:</p>
<pre><code class="lang-bash">curl -X &quot;POST&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --data-urlencode &quot;title=Star+Wars&quot; \
    --data-urlencode &quot;year=1977&quot; \
    --data-urlencode &quot;rating=8.7&quot;
</code></pre>
<p>Or, if you prefer, with a JSON object:</p>
<pre><code class="lang-bash">curl -X &quot;POST&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;title\&quot;:\&quot;Star Wars\&quot;,\&quot;year\&quot;:1977,\&quot;rating\&quot;:8.7}&quot;
</code></pre>
<p>This operation will return the newly created document, with the following generated ID:</p>
<pre><code class="lang-js">{&quot;title&quot;:&quot;Star Wars&quot;,&quot;id&quot;:&quot;115992383516607958&quot;,&quot;year&quot;:1977,&quot;rating&quot;:8.7}
</code></pre>
<p>The URL we just created stored a new document in our <code>app</code>&#39;s <code>service</code>, inside the <em>collection</em> <code>movies</code>. More information on how to setup this datastore URL can be seen in the section <a href="#custom_apis"> Custom APIs </a>. For now, we only need to know that within the path where the data is mounted, the URL will be interpreted as a key that points to a stored resource like the one below:</p>
<pre><code>/collection_name/document_id/document_property/document_inner_property
</code></pre><p>For example, to reference the newly created <em>Star Wars</em> rating, we can use the relative path:</p>
<pre><code>/movies/115992383516607958/rating
</code></pre><p>From this point, update and delete operations can be performed at any level of the resource. For example, we can update the existing document by adding a new field:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PATCH&quot; &quot;http://liferay.io/app/service/movies/115992383516607958&quot; \
    --data-urlencode &quot;stars=Mark+Hamill&quot; \
    --data-urlencode &quot;stars=Harrison+Ford&quot; \
    --data-urlencode &quot;stars=Carrie+Fisher&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .path(&#39;115992383516607958&#39;)
   .form(&#39;stars&#39;, &#39;Mark Hamill&#39;)
   .form(&#39;stars&#39;, &#39;Harrison Ford&#39;)
   .form(&#39;stars&#39;, &#39;Carrie Fisher&#39;)
   .patch();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .path(&quot;115992383516607958&quot;)
   .form(&quot;stars&quot;, &quot;Mark Hamill&quot;)
   .form(&quot;stars&quot;, &quot;Harrison Ford&quot;)
   .form(&quot;stars&quot;, &quot;Carrie Fisher&quot;)
   .patch();
</code></pre>
<p>The response is the modified document:</p>
<pre><code class="lang-js">{&quot;title&quot;:&quot;Star Wars&quot;,&quot;id&quot;:&quot;115992383516607958&quot;,&quot;year&quot;:1977,&quot;rating&quot;:8.7,&quot;stars&quot;:[&quot;Mark Hamill&quot;, &quot;Harrison Ford&quot;, &quot;Carrie Fisher&quot;]}
</code></pre>
<p>To create a document with a custom ID, or override an existing one, we can use the PUT method at the document level:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies/star_wars_v&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;title\&quot;:\&quot;Star Wars: Episode V - The Empire Strikes Back\&quot;,\&quot;year\&quot;:1980,\&quot;rating\&quot;:8.8}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .path(&#39;star_wars_v&#39;)
   .put({title:&#39;Star Wars: Episode V - The Empire Strikes Back&#39;,year:1980,rating:8.8});
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .path(&quot;star_wars_v&quot;)
   .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
   .put(&quot;{\&quot;title\&quot;:\&quot;Star Wars: Episode V - The Empire Strikes Back\&quot;,\&quot;year\&quot;:1980,\&quot;rating\&quot;:8.8}&quot;);
</code></pre>
<p>To delete a field, document, or the entire collection, we just use the DELETE method:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;DELETE&quot; &quot;http://liferay.io/app/service/movies/star_wars_v/title&quot;
curl -X &quot;DELETE&quot; &quot;http://liferay.io/app/service/movies/star_wars_v&quot;
curl -X &quot;DELETE&quot; &quot;http://liferay.io/app/service/movies&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies/star_wars_v/title&#39;).delete();
Launchpad.url(&#39;http://liferay.io/app/service/movies/star_wars_v&#39;).delete();
Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;).delete();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies/star_wars_v/title&quot;).delete();
Launchpad.url(&quot;http://liferay.io/app/service/movies/star_wars_v&quot;).delete();
Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;).delete();
</code></pre>
<p>For a detailed description of write operations, such as how to push and delete elements in a list, batch creation of documents in a collection, and more, see the section <a href="https://github.com/liferay-apps/landing/wiki/Data-Operations">Data Operations</a>.</p>
<p><a name="realtime_database_read_data" /></p>
<h3 id="2-read-data">2. Read Data</h3>
<p>Reading data from our storage is also as simple as getting a URL resource:</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/service/movies/star_wars_v&quot;
</code></pre>
<p>The result is the document as a JSON:</p>
<pre><code class="lang-json">{&quot;id&quot;:&quot;star_wars_v&quot;,&quot;title&quot;:&quot;Star Wars: Episode V - The Empire Strikes Back&quot;,&quot;year&quot;:1980,&quot;rating&quot;:8.8}
</code></pre>
<p>We can also get any field value using the full path:</p>
<pre><code class="lang-bash">curl -X &quot;GET&quot; &quot;http://liferay.io/app/service/movies/star_wars_v/title&quot;
</code></pre>
<p>The full path returns the raw content in the response body:</p>
<pre><code>Star Wars: Episode V - The Empire Strikes Back
</code></pre><p>Requesting the entire <code>movies</code> collection using <code>curl -X &quot;GET&quot; &quot;http://liferay.io/app/service/movies&quot;</code> results in the first <code>10</code> documents stored:</p>
<pre><code class="lang-json">[
  {&quot;id&quot;:&quot;star_wars_i&quot;,&quot;title&quot;:&quot;Star Wars: Episode I - The Phantom Menace&quot;,&quot;year&quot;:1999,&quot;rating&quot;:6.5},
  {&quot;id&quot;:&quot;star_wars_ii&quot;,&quot;title&quot;:&quot;Star Wars: Episode II - Attack of the Clones&quot;,&quot;year&quot;:2002,&quot;rating&quot;:6.7},
  {&quot;id&quot;:&quot;star_wars_iii&quot;,&quot;title&quot;:&quot;Star Wars: Episode III - Revenge of the Sith&quot;,&quot;year&quot;:2005,&quot;rating&quot;:7.7},
  {&quot;id&quot;:&quot;star_wars_iv&quot;,&quot;title&quot;:&quot;Star Wars: Episode IV - A New Hope&quot;,&quot;year&quot;:1977,&quot;rating&quot;:8.7},
  {&quot;id&quot;:&quot;star_wars_v&quot;,&quot;title&quot;:&quot;Star Wars: Episode V - The Empire Strikes Back&quot;,&quot;year&quot;:1980,&quot;rating&quot;:8.8},
  {&quot;id&quot;:&quot;star_wars_vi&quot;,&quot;title&quot;:&quot;Star Wars: Episode VI - Return of the Jedi&quot;,&quot;year&quot;:1983,&quot;rating&quot;:8.4},
  {&quot;id&quot;:&quot;star_wars_vii&quot;,&quot;title&quot;:&quot;Star Wars: Episode VII - The Force Awakens&quot;,&quot;year&quot;:2015}
]
</code></pre>
<p>The result is ordered by the document <code>id</code>, as we can see in the list above. We can select the order we want the results to be in, by passing a sort parameter, using the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;sort\&quot;:{\&quot;rating\&quot;:\&quot;desc\&quot;}}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .sort(&#39;rating&#39;, &#39;desc&#39;)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .sort(&quot;rating&quot;, &quot;desc&quot;)
   .get();
</code></pre>
<p>As expected, the result would be the following list:</p>
<pre><code class="lang-json">[
  {&quot;id&quot;:&quot;star_wars_v&quot;,&quot;title&quot;:&quot;Star Wars: Episode V - The Empire Strikes Back&quot;,&quot;year&quot;:1980,&quot;rating&quot;:8.8},
  {&quot;id&quot;:&quot;star_wars_iv&quot;,&quot;title&quot;:&quot;Star Wars: Episode IV - A New Hope&quot;,&quot;year&quot;:1977,&quot;rating&quot;:8.7},
  {&quot;id&quot;:&quot;star_wars_vi&quot;,&quot;title&quot;:&quot;Star Wars: Episode VI - Return of the Jedi&quot;,&quot;year&quot;:1983,&quot;rating&quot;:8.4},
  {&quot;id&quot;:&quot;star_wars_iii&quot;,&quot;title&quot;:&quot;Star Wars: Episode III - Revenge of the Sith&quot;,&quot;year&quot;:2005,&quot;rating&quot;:7.7},
  {&quot;id&quot;:&quot;star_wars_ii&quot;,&quot;title&quot;:&quot;Star Wars: Episode II - Attack of the Clones&quot;,&quot;year&quot;:2002,&quot;rating&quot;:6.7},
  {&quot;id&quot;:&quot;star_wars_i&quot;,&quot;title&quot;:&quot;Star Wars: Episode I - The Phantom Menace&quot;,&quot;year&quot;:1999,&quot;rating&quot;:6.5},
  {&quot;id&quot;:&quot;star_wars_vii&quot;,&quot;title&quot;:&quot;Star Wars: Episode VII - The Force Awakens&quot;,&quot;year&quot;:2015}
]
</code></pre>
<p>Notice the Episode VII has no rating, as it was not released yet, thus it&#39;s sorted as the last document.</p>
<p>In addition to sorting the results, we can also apply filters using the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:[&quot; \
    --data &quot;{\&quot;year\&quot;:{\&quot;operator\&quot;:\&quot;&lt;\&quot;,\&quot;value\&quot;:2000}},&quot; \
    --data &quot;{\&quot;rating\&quot;:{\&quot;operator\&quot;:\&quot;&gt;\&quot;,\&quot;value\&quot;:8.5}}&quot; \
    --data &quot;]}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .filter(&#39;year&#39;, &#39;&lt;&#39;, 2000)
   .filter(&#39;rating&#39;, &#39;&gt;&#39;, 8.5)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .filter(&quot;year&quot;, &quot;&lt;&quot;, 2000)
   .filter(&quot;rating&quot;, &quot;&gt;&quot;, 8.5)
   .get();
</code></pre>
<p>The result of the filters just used is the following entries:</p>
<pre><code class="lang-json">[
  {&quot;id&quot;:&quot;star_wars_iv&quot;,&quot;title&quot;:&quot;Star Wars: Episode IV - A New Hope&quot;,&quot;year&quot;:1977,&quot;rating&quot;:8.7},
  {&quot;id&quot;:&quot;star_wars_v&quot;,&quot;title&quot;:&quot;Star Wars: Episode V - The Empire Strikes Back&quot;,&quot;year&quot;:1980,&quot;rating&quot;:8.8}
]
</code></pre>
<p>We can also paginate the result using the <code>limit</code> and <code>offset</code> properties. Combining all the tools we&#39;ve learned so far, we can run a detailed query on our data:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{&quot; \
    --data &quot;\&quot;filter\&quot;:{\&quot;year\&quot;:{\&quot;operator\&quot;:\&quot;&gt;\&quot;,\&quot;value\&quot;:2000}},&quot; \
    --data &quot;\&quot;sort\&quot;:{\&quot;rating\&quot;:\&quot;asc\&quot;},&quot; \
    --data &quot;\&quot;limit\&quot;:2,&quot; \
    --data &quot;\&quot;offset\&quot;:1&quot; \
    --data &quot;}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .filter(&#39;year&#39;, &#39;&gt;&#39;, 2000)
   .sort(&#39;rating&#39;)
   .limit(2)
   .offset(1)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .filter(&quot;year&quot;, &quot;&gt;&quot;, 2000)
   .sort(&quot;rating&quot;)
   .limit(2)
   .offset(1)
   .get();
</code></pre>
<p>Notice that filtering by the year we only get episodes I, II, III and VII. Applying the rating sort will give us this same order. We also limited the result to show only 2 documents, and skipped the first one. The final result is the following entries:</p>
<pre><code class="lang-json">[
  {&quot;id&quot;:&quot;star_wars_ii&quot;,&quot;title&quot;:&quot;Star Wars: Episode II - Attack of the Clones&quot;,&quot;year&quot;:2002,&quot;rating&quot;:6.7},
  {&quot;id&quot;:&quot;star_wars_iii&quot;,&quot;title&quot;:&quot;Star Wars: Episode III - Revenge of the Sith&quot;,&quot;year&quot;:2005,&quot;rating&quot;:7.7}
]
</code></pre>
<p>We support all basic SQL-like operators (<code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>~</code>), as well as <code>any</code> and <code>none</code> to filter elements in a list. We also give support for search operators, which we will see in more details in the section <a href="#realtime_database_search_data_in_realtime"> Search Data in Realtime </a>. For a full list of supported filters and query parameters, see <a href="https://github.com/liferay-apps/landing/wiki/Data-Operations">Data Operations</a>.</p>
<p><a name="realtime_database_search_data_in_realtime" /></p>
<h3 id="3-search-data-in-realtime">3. Search Data in Realtime</h3>
<p>Well, we did some great stuff with basic http methods, like create, update, and delete JSON documents. We also learned how to retrieve documents with filter, sort, and pagination. What if we need to do more powerful queries with our documents? Well, in Launchpad you can do a text search, handle user misspellings, show the number of documents by category with your data, and much more.</p>
<p>First take a look at the text search. Its a simple, yet very powerful way to filter our results by a text query. Using the movie database we created before, let&#39;s search for a Star Wars movie by the episode title, like <code>&quot;Revenge of the Sith&quot;</code>. We are not interested if the letter is in upper or lower case, since we are using English connectors like <code>&quot;of&quot;</code> and <code>&quot;the&quot;</code>. We want something flexible enough it will also work for texts like &quot;The revenge of the Sith&quot;, or &quot;Sith&#39;s revenge&quot;. Our <code>match</code> operator is just what we need to run the search.</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;match\&quot;,\&quot;value\&quot;:\&quot;Sith&#39;s Revenge\&quot;}}}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .get(Filter.match(&#39;title&#39;, &quot;Sith&#39;s revenge&quot;));
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .get(Filter.match(&quot;title&quot;, &quot;Sith&#39;s revenge&quot;));
</code></pre>
<p>The result of the <code>match</code> operator query is the following entry:</p>
<pre><code class="lang-json">[{&quot;id&quot;:&quot;star_wars_iii&quot;,&quot;title&quot;:&quot;Star Wars: Episode III - Revenge of the Sith&quot;,&quot;year&quot;:2005,&quot;rating&quot;:7.7}]
</code></pre>
<p>We can also use simple text operators in our match:</p>
<p>Curl</p>
<pre><code class="lang-bash"># we can run this
curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;match\&quot;,\&quot;value\&quot;:\&quot;(jedi | force) -return\&quot;}}}&quot;

# or this
curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;match\&quot;,\&quot;value\&quot;:\&quot;awake*\&quot;}}}&quot;

# or even this
curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;match\&quot;,\&quot;value\&quot;:\&quot;wakens~\&quot;}}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">// we can run this
Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .get(Filter.match(&#39;title&#39;, &#39;(jedi | force) -return&#39;));

// or this
Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .get(Filter.match(&#39;title&#39;, &#39;awake*&#39;));

// or even this
Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .get(Filter.match(&#39;title&#39;, &#39;wakens~&#39;));
</code></pre>
<p>Java</p>
<pre><code class="lang-java">// we can run this
Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .get(Filter.match(&quot;title&quot;, &quot;(jedi | force) -return&quot;));

// or this
Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .get(Filter.match(&quot;title&quot;, &quot;awake*&quot;));

// or even this
Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .get(Filter.match(&quot;title&quot;, &quot;wakens~&quot;));
</code></pre>
<p>Any search in the previous example results in the following match:</p>
<pre><code class="lang-json">[{&quot;id&quot;:&quot;star_wars_vii&quot;,&quot;title&quot;:&quot;Star Wars: Episode VII - The Force Awakens&quot;,&quot;year&quot;:2015}]
</code></pre>
<p>What we did with <code>*</code> can also be done with the <code>prefix</code> operator <code>Filter.prefix(&#39;title&#39;, &#39;awake&#39;)</code>. The fuzziness we added to <code>wakens</code> using <code>~</code>, can also be done explicitly with the <code>fuzzy</code> operator <code>Filter.fuzzy(&#39;title&#39;, &#39;wakens&#39;)</code>. For more text search operators, see <a href="https://github.com/liferay-apps/landing/wiki/Data-Operations">Data Operations</a>.</p>
<p>So far we are still just filtering data with filters. We can do so much more than that! If we use query search instead of filter to send those filters to the server, we can also get information about how relevant a document is to a given search, and order our results by this criteria. Let us introduce this with a new filter that allows us to query movies with a title similar to a given text:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;similar\&quot;,\&quot;value\&quot;:\&quot;The attack an awaken Jedi uses to strike a Sith is pure force!\&quot;}}}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .search(Filter.similar(&#39;title&#39;, &#39;The attack an awaken Jedi uses to strike a Sith is pure force!&#39;))
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .search(Filter.similar(&quot;title&quot;, &quot;The attack an awaken Jedi uses to strike a Sith is pure force!&quot;))
   .get();
</code></pre>
<p>We receive not only the documents that match the filter, but also search metadata:</p>
<pre><code class="lang-json">{
    &quot;total&quot;: 5,
    &quot;documents&quot;: [
        {
            &quot;title&quot;: &quot;Star Wars: Episode VII - The Force Awakens&quot;,
            &quot;id&quot;: &quot;star_wars_vii&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode V - The Empire Strikes Back&quot;,
            &quot;id&quot;: &quot;star_wars_v&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode VI - Return of the Jedi&quot;,
            &quot;id&quot;: &quot;star_wars_vi&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode III - Revenge of the Sith&quot;,
            &quot;id&quot;: &quot;star_wars_iii&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode II - Attack of the Clones&quot;,
            &quot;id&quot;: &quot;staw_wars_ii&quot;
        }
    ],
    &quot;scores&quot;: {
        &quot;star_wars_ii&quot;: 0.13102644681930542,
        &quot;star_wars_iii&quot;: 0.13102644681930542,
        &quot;star_wars_v&quot;: 0.13102644681930542,
        &quot;star_wars_vi&quot;: 0.13102644681930542,
        &quot;star_wars_vii&quot;: 0.5241057872772217
    },
    &quot;queryTime&quot;: 1
}
</code></pre>
<p>Notice that the score of the <code>star_wars_vii</code> document is bigger than the other matches, indicating its title is more similar to the given filter than the others. The documents in the result are now ordered by the <em>relevance</em> of the document, expressed as a number in the <code>scores</code> metadata, rather than the document&#39;s ID. Now we can show not only filtered results, but also order our results by relevance!</p>
<p>Want more? Well, let&#39;s make things even easier for the user! Adding one entry to the search query we can automatically highlight the words that matched our query, showing not only how relevant the document is to the search, but also where it matches our criteria. We can do this with small changes in our previous search, using the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;title\&quot;:{\&quot;operator\&quot;:\&quot;similar\&quot;,\&quot;value\&quot;:\&quot;The attack an awakened Jedi uses to strike a Sith is pure force!\&quot;}},&quot; \
    --data &quot;\&quot;highlight\&quot;:\&quot;title\&quot;}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .search(Filter.similar(&#39;title&#39;, &#39;The attack an awakened Jedi uses to strike a Sith is pure force!&#39;))
   .highlight(&#39;title&#39;)
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .search(Filter.similar(&quot;title&quot;, &quot;The attack an awakened Jedi uses to strike a Sith is pure force!&quot;))
   .highlight(&quot;title&quot;)
   .get();
</code></pre>
<p>As you can see in the code below, our keywords are highlighted in the results:</p>
<pre><code class="lang-json">{
    &quot;total&quot;: 5,
    &quot;documents&quot;: [
        {
            &quot;title&quot;: &quot;Star Wars: Episode VII - The &lt;em&gt;Force&lt;/em&gt; &lt;em&gt;Awakens&lt;/em&gt;&quot;,
            &quot;id&quot;: &quot;star_wars_vii&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode V - The Empire &lt;em&gt;Strikes&lt;/em&gt; Back&quot;,
            &quot;id&quot;: &quot;star_wars_v&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode VI - Return of the &lt;em&gt;Jedi&lt;/em&gt;&quot;,
            &quot;id&quot;: &quot;star_wars_vi&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode III - Revenge of the &lt;em&gt;Sith&lt;/em&gt;&quot;,
            &quot;id&quot;: &quot;star_wars_iii&quot;
        },
        {
            &quot;title&quot;: &quot;Star Wars: Episode II - &lt;em&gt;Attack&lt;/em&gt; of the Clones&quot;,
            &quot;id&quot;: &quot;star_wars_ii&quot;
        }
    ],
    &quot;scores&quot;: {
        &quot;star_wars_ii&quot;: 0.13102644681930542,
        &quot;star_wars_iii&quot;: 0.13102644681930542,
        &quot;star_wars_v&quot;: 0.13102644681930542,
        &quot;star_wars_vi&quot;: 0.13102644681930542,
        &quot;star_wars_vii&quot;: 0.5241057872772217
    },
    &quot;queryTime&quot;: 1
}
</code></pre>
<p>The third search feature we will now introduce is also quite simple, but can be applied to generate meaningful statistical information about our data. What if we need to compare the average rating the first three movies received with the last three movies? Well, we can do that with aggregations, using the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/movies&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:{\&quot;year\&quot;:{\&quot;operator\&quot;:\&quot;&lt;\&quot;,\&quot;value\&quot;:1990}},&quot; \
    --data &quot;\&quot;aggregate\&quot;:{\&quot;rating\&quot;:{\&quot;name\&quot;:\&quot;Old Movies\&quot;,\&quot;operator\&quot;:\&quot;avg\&quot;}},&quot; \
    --data &quot;\&quot;type\&quot;:\&quot;count\&quot;}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/movies&#39;)
   .filter(Filter.lt(&#39;year&#39;, 1990))
   .aggregate(&#39;Old Movies&#39;, &#39;rating&#39;, &#39;avg&#39;)
   .count()
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/movies&quot;)
   .filter(Filter.lt(&quot;year&quot;, 1990))
   .aggregate(&quot;Old Movies&quot;, &quot;rating&quot;, &quot;avg&quot;)
   .count()
   .get();
</code></pre>
<p>The <code>count</code> we added to the query informed the server we are not interested in the documents themselves, but rather the number of matches and search metadata. The result in this case will be the following data:</p>
<pre><code class="lang-json">{
    &quot;total&quot;: 3,
    &quot;queryTime&quot;: 13,
    &quot;aggregations&quot;: {
        &quot;Old Movies&quot;: 8.633333333333333
    }
}
</code></pre>
<p>Cool, right? Just run another query for the newest movies and then you have the data you need to compare them. There are some other operators that you might find useful: <code>min</code>, <code>max</code>, <code>sum</code>, <code>histogram</code>, and even a generic <code>stats</code> that returns several statistics over the field. Take a look at the example below to see the operators in action:</p>
<pre><code class="lang-json">{
    &quot;total&quot;: 3,
    &quot;queryTime&quot;: 8,
    &quot;aggregations&quot;: {
        &quot;Old Movies&quot;: {
            &quot;average&quot;: 8.633333333333333,
            &quot;count&quot;: 3,
            &quot;max&quot;: 8.8,
            &quot;min&quot;: 8.4,
            &quot;name&quot;: &quot;Old Movies&quot;,
            &quot;standardDeviation&quot;: null,
            &quot;sum&quot;: 25.9,
            &quot;sumOfSquares&quot;: null,
            &quot;variance&quot;: null
        }
    }
}
</code></pre>
<p>To see all aggregation operations we offer, check out <a href="https://github.com/liferay-apps/landing/wiki/Data-Operations">Data Operations</a>.</p>
<p>The last search feature we will cover here needs a little setup before we put our documents in the datastore, but it&#39;s not as complicated as it sounds. First, let&#39;s cover some basics on the datatypes we support. As we said before, we offer a JSON storage, thus we support all JSON types, with the restriction that arrays must be of elements of the same type. Once we put a new document in a collection, we can automatically derive the datatype of the fields added, and bind the fields to that datatype. So, if we try to run the following code:</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/places/my_place/foo&quot; \
    --data &quot;bar&quot;
</code></pre>
<p>And then run the following code:</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/places/my_place/foo&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;key\&quot;:\&quot;value\&quot;}&quot;
</code></pre>
<p>We will receive an error:</p>
<pre><code class="lang-json">{
    &quot;code&quot;: 400,
    &quot;message&quot;: &quot;Bad Request&quot;,
    &quot;errors&quot;: [
        {
            &quot;reason&quot;: &quot;invalidDocumentValue&quot;,
            &quot;message&quot;: &quot;Document cannot be saved. One or more document values could not be parsed to the correct type.&quot;
        }
    ]
}
</code></pre>
<p>The error was triggered because we could not convert the given data to the datatype bounded to that field. Of course, we can do simple conversions, like between numbers and strings, but whenever we fail we will inform you something is wrong. To access those datatypes, you can just get the root of your service data with a <code>curl -X &quot;GET&quot; &quot;http://liferay.io/app/service&quot;</code>, and receive something like the following result:</p>
<pre><code class="lang-json">[
    {
        &quot;movies&quot;: {
            &quot;title&quot;: &quot;string&quot;,
            &quot;year&quot;: &quot;long&quot;,
            &quot;rating&quot;: &quot;double&quot;
        }
    },
    {
        &quot;places&quot;: {
            &quot;foo&quot;: &quot;string&quot;
        }
    }
]
</code></pre>
<p>If we want to inform the server of the datatype of a collection field, before it receives its first document, we can POST/PATCH the data root with the mapping information:</p>
<pre><code class="lang-bash">curl -X &quot;PATCH&quot; &quot;http://liferay.io/app/service&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;places\&quot;:{\&quot;location\&quot;:\&quot;geo_point\&quot;}}&quot;
</code></pre>
<p>We can never update a already mapped field, but we can map new fields in an existing collection, as we did in the request above. When we manually map our collection, we can use some extra datatypes that are not mapped dynamically: <code>date</code>, <code>geo_point</code>, and <code>geo_shape</code>. We will focus on <code>geo_point</code> for this next feature.</p>
<p>So, we mapped a field called <code>location</code>, in the collection <code>places</code>, as representing a geolocation point. This means we can operate, filter, and aggregate the places we put in that collection, using geo filters over this field! Let&#39;s try something simple: find cinemas close to <a href="https://www.google.com.br/maps/place/Waterloo+Station/@51.5031653,-0.1123051,17z/data=!3m1!4b1!4m2!3m1!1s0x487604b9c09f521d:0x1d0598197b5003ba?hl=en">London&#39;s Waterloo Station</a>. To run the search criteria, we&#39;ll use the following code:</p>
<p>Curl</p>
<pre><code class="lang-bash">curl -X &quot;PUT&quot; &quot;http://liferay.io/app/service/places&quot; \
    --header &quot;Content-Type: application/json&quot; \
    --data &quot;{\&quot;filter\&quot;:[&quot; \
    --data &quot;{\&quot;category\&quot;:{\&quot;operator\&quot;:\&quot;any\&quot;,\&quot;value\&quot;:\&quot;cinema\&quot;}},&quot; \
    --data &quot;{\&quot;location\&quot;:{\&quot;operator\&quot;:\&quot;gd\&quot;,\&quot;value\&quot;:{\&quot;location\&quot;:\&quot;51.5031653,-0.1123051\&quot;,\&quot;max\&quot;:\&quot;1mi\&quot;}}}&quot; \
    --data &quot;]}&quot;
</code></pre>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/places&#39;)
   .filter(Filter.any(&#39;category&#39;, &#39;cinema&#39;))
   .filter(Filter.distance(&#39;location&#39;, &#39;51.5031653,-0.1123051&#39;, &#39;1mi&#39;))
   .get();
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/places&quot;)
   .filter(Filter.any(&quot;category&quot;, &quot;cinema&quot;))
   .filter(Filter.distance(&quot;location&quot;, &quot;51.5031653,-0.1123051&quot;, &quot;1mi&quot;))
   .get();
</code></pre>
<p>Our result is the following matches:</p>
<pre><code class="lang-json">[
    {
        &quot;name&quot;: &quot;BFI IMAX&quot;,
        &quot;location&quot;: &quot;51.5126928,-0.12052&quot;,
        &quot;id&quot;: &quot;116686224946770924&quot;,
        &quot;category&quot;: [
            &quot;cinema&quot;
        ]
    },
    {
        &quot;name&quot;: &quot;Cinema Museum&quot;,
        &quot;location&quot;: &quot;51.501661,-0.1177734&quot;,
        &quot;id&quot;: &quot;116686224946770925&quot;,
        &quot;category&quot;: [
            &quot;cinema&quot;,
            &quot;museum&quot;
        ]
    },
    {
        &quot;name&quot;: &quot;Roxy Bar and Screen&quot;,
        &quot;location&quot;: &quot;51.5012603,-0.1146835&quot;,
        &quot;id&quot;: &quot;116686224946770926&quot;,
        &quot;category&quot;: [
            &quot;cinema&quot;,
            &quot;bar&quot;,
            &quot;restaurant&quot;
        ]
    }
]
</code></pre>
<p>Now we can plug a map to our app and let users see and filter places with just a few lines of code.</p>
<h4 id="realtime">Realtime</h4>
<p>Well, we presented a lot of features for data filtering and search. You may be wondering where the realtime aspect is in all of this. Well, it&#39;s throughout the features we just presented to you. To access our data in realtime, all we need to do is change the Launchpad API method we use to the <code>watch</code> method:</p>
<p>JavaScript</p>
<pre><code class="lang-js">Launchpad.url(&#39;http://liferay.io/app/service/places&#39;)
   .filter(Filter.any(&#39;category&#39;, &#39;cinema&#39;))
   .filter(Filter.distance(&#39;location&#39;, &#39;51.5031653,-0.1123051&#39;, &#39;1mi&#39;))
   .watch()
   .on(&#39;changes&#39;, doSomethingWithReceivedData)
   .on(&#39;fail&#39;, handleFailure);
</code></pre>
<p>Java</p>
<pre><code class="lang-java">Launchpad.url(&quot;http://liferay.io/app/service/places&quot;)
   .filter(Filter.any(&quot;category&quot;, &quot;cinema&quot;))
   .filter(Filter.distance(&quot;location&quot;, &quot;51.5031653,-0.1123051&quot;, &quot;1mi&quot;))
   .watch()
   .on(&#39;changes&#39;, this::doSomethingWithReceivedData)
   .on(&#39;fail&#39;, this::handleFailure);
</code></pre>
<p>Now every time the storage detects changes that affects the query you&#39;re watching, you will receive a <code>changes</code> notification with the response body you&#39;d receive if you had done an HTTP GET instead. Furthermore, every time this change leads to an HTTP error response, you&#39;ll receive the error object in a <code>fail</code> notification on the client! For more information about the <code>RealTime</code> object we return on <code>watch</code> calls, read the section <a href="#custom_apis_create_realtime_service"> Create Realtime Service </a>.</p>
<p><a name="custom_apis" /></p>
<h2 id="custom-apis">Custom APIs</h2>
<p><a name="custom_apis_understand_api.json" /></p>
<h3 id="1-understand-api-json">1. Understand api.json</h3>
<p>Launchpad enables you to create apps, and each app is composed by one or more services. A service is exposed with a REST interface that you can configure in the <code>api.json</code> file. A service api consists of a list of apis, each following the format:</p>
<pre><code class="lang-json">{
  &quot;path&quot;: null,
  &quot;method&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;],
  &quot;handler&quot;: null,
  &quot;title&quot;: null,
  &quot;description&quot;: null,
  &quot;auth&quot;: null,
  &quot;parameters&quot;: null,
  &quot;body&quot;: null,
  &quot;visibility&quot;: true,
  &quot;blocking&quot;: true
}
</code></pre>
<p>These are the default values for an api. The service will use this list of api definitions to create a router for your service, and then each request that matches your service path will be handled by this router. Thus, it&#39;s important to notice that the order in which these apis are described in your <code>api.json</code> is the same order your service will try to match and process your request. So, for example, if you define one api to describe your authorization logic for a path, and another to define a function to handle the request, you need to put them in the proper order inside the file.</p>
<h4 id="path">Path</h4>
<p>The <code>path</code> is used by your service router to define which requests will be affected by this api definition. The base url for an service named <code>myService</code> in an app called <code>myApp</code> is:</p>
<pre><code>liferay.io/myApp/myService
</code></pre><p>Your path then only need to specify the url section that comes after this base url in a incoming request. You can specify fixed paths like:</p>
<pre><code>/my/api/route
</code></pre><p>Or patterns to match the request url:</p>
<pre><code>/sum/:first(\\d+)/:second(\\d+)
</code></pre><p>This patterns enables you to create a RegEx pattern to filter the urls, and also name the extracted url segment for future reference. The example above will match any request with two numbers after <code>sum</code>, like <code>/sum/123/456</code>, but not requests like <code>/sum/text</code> or <code>/sum/123/word</code>. You can also match only the prefix of the request, using the wildcard:</p>
<pre><code>/api/prefix/*
</code></pre><p>This will match paths like <code>/api/prefix</code>, <code>/api/prefix/path</code>, and so on...</p>
<p>Notice the path from two different apis may overlap, or even be identical. In this case, your service will match the first api, in the order they&#39;re described in your <code>api.json</code>, and if this one doesn&#39;t handle the request or explicitly calls <code>next</code> inside the handler, then it will match and execute the second one.</p>
<p>You can also mount data in your path using the token <code>@</code>:</p>
<pre><code>/my/base/path/@/users/*
</code></pre><p>This example will mount the collection <code>users</code> after the path <code>/my/base/path</code>, so requests like:</p>
<pre><code>/my/base/path/users/1/name
</code></pre><p>Will access the name of the user with ID <code>1</code>. For more information on mounting data paths, see <a href="https://github.com/liferay-apps/landing/wiki/Data-Operations">Data Operations</a>.</p>
<p>Once you&#39;ve mapped all your paths, you can access it by merging the path with your service base url:</p>
<pre><code class="lang-bash">curl &quot;http://liferay.io/myApp/myService/my/mapped/path&quot;
</code></pre>
<h4 id="method">Method</h4>
<p>The <code>method</code> works as a filter for requests that will be routed to this api definition. By default, all HTTP requests are mapped to an api, but you can change it to any subset you need.</p>
<h4 id="handler">Handler</h4>
<p>The <code>handler</code> is where you can point to a function to receive the request and process it. It can be in <a href="#custom_apis_create_java_service"> Java </a> or href=&quot;#custom_apis_create_javascript_service&quot;&gt; Javascript </a>.</p>
<p>Javascript</p>
<pre><code class="lang-json">{
  &quot;path&quot;: &quot;/hello&quot;,
  &quot;method&quot;: &quot;GET&quot;,
  &quot;handler&quot;: &quot;api.js#handler&quot;
}
</code></pre>
<p>Java</p>
<pre><code class="lang-java">{
  &quot;path&quot;: &quot;hello&quot;,
  &quot;method&quot;: &quot;GET&quot;,
  &quot;handler&quot;: &quot;foo.Bar#handler&quot;
}
</code></pre>
<p>The router will not continue to match the request with your service&#39;s apis after it encounters a handler or a data path, so its up to you finishing the response in your code:</p>
<pre><code class="lang-js">function handler(request, response) {
   // process request
   response.end(&#39;Hello Launchpad World!&#39;);
}
</code></pre>
<p>Java</p>
<pre><code class="lang-java">public void handler(Request request, Response response) {
   // process request
   response.end(&quot;Hello Launchpad World!&quot;);
}
</code></pre>
<p>Or just return the string to be used as body in a <code>200 OK</code> response:</p>
<p>Javascript</p>
<pre><code class="lang-js">function handler() {
   return &#39;Hello Launchpad World!&#39;;
}
</code></pre>
<p>Java</p>
<pre><code class="lang-java">public String handler() {
   return &quot;Hello Launchpad World!&quot;;
}
</code></pre>
<p>Nonetheless, if you want to process the request and delegate it to the next routes, you can call explicitly <code>request.next()</code> inside your code and make the router continue the iteration over your <code>api.json</code>.</p>
<pre><code class="lang-js">function handler(Request request) {
   // process request
   request.next();
}
</code></pre>
<p>Java</p>
<pre><code class="lang-java">public void handler(Request request) {
   // process request
   request.next();
}
</code></pre>
<h4 id="title-and-description">Title and Description</h4>
<p>The <code>title</code> and <code>description</code> are optional information that can be used as documentation for your api. In you <code>api.json</code>, just fill with string values:</p>
<pre><code class="lang-json">{
   &quot;path&quot;: &quot;@/users&quot;,
   &quot;title&quot;: &quot;User collection&quot;,
   &quot;description&quot;: &quot;Service&#39;s user collection, that can be used to save and access user information.&quot;
}
</code></pre>
<h4 id="auth">Auth</h4>
<p>The <code>auth</code> is an object that describes all criteria an authenticated user needs to meet in order to have access this path. If the authorization of the request fails, the service may redirect the request to a registered login page (see <a href="#authentication_configuration"> Authentication Configuration </a> to know how to setup a login page for your app), or respond with <code>404 Not Found</code> to avoid giving the unauthorized user any information about your service.</p>
<p>This auth object has the following fields:</p>
<pre><code class="lang-json">{
  &quot;auth&quot;: {
    &quot;permissions&quot;: [&quot;permission1&quot;, &quot;permission2&quot;],
    &quot;roles&quot;: [&quot;role1&quot;, &quot;role2&quot;],
    &quot;validator&quot;: &quot;$auth.id === 123&quot;
  }
}
</code></pre>
<p>The <code>permissions</code> field list all permissions a user must have to be authorized. This permissions can be resolved from the user permissions, or from any role he may have that has this permission (see <a href="#authentication_configuration"> Authentication Configuration </a> to know how to define the roles&#39; permissions for your app).</p>
<p>The <code>roles</code> field list all roles a user must have to be authorized. Note that even if the user has all permissions that defined a role in your app, he will not be granted access to this api if he doesn&#39;t have the role itself. For example, if you configured your app so the role <code>admin</code> has permissions <code>[&quot;read&quot;, &quot;write&quot;]</code>, a user will not access you api without the role <code>admin</code> even if he has both permissions separately.</p>
<p>The <code>validator</code> field enables you to describe any javascript expression to authorize the request. You can access any request data available in the scripting environment (see more about this bellow with api parameters).</p>
<h4 id="parameters">Parameters</h4>
<h4 id="body">Body</h4>
<h4 id="visibility">Visibility</h4>
<p>You can specify the visibility of your service at the api level. If you want to map a path that only internal services inside your app will be able to reach, you can set this flag to <code>false</code> in your api definition. By default its set to <code>true</code>.</p>
<h4 id="blocking">Blocking</h4>
<p>You can specify the kind of process your handler will execute in your api definition. If you will execute a code too complex, or perform any blocking IO request or function, its better to set the <code>blocking</code> flag to <code>true</code>, so the server will allocate a special part of the resources to process this request and leave your HTTP server available to receive new requests.</p>
<p>If your handler is a light code and you want to execute it really fast, you can set this flag to <code>false</code> and let the server execute it as fast as it can without allocating any special resource for that. But here you must thread lightly, because you&#39;ll be consuming resources from your HTTP server and possibly affecting new requests to your app. Only change this flag to <code>false</code> if you really know how its going to affect to your server. The default value for this flag is <code>true</code>.</p>

				</article>
			</div>
		</div>
	</main>


	<script src="/scripts/fade.js"></script>
	
	<script src="/vendor/scripts/codemirror.js"></script>
	<script src="/vendor/scripts/javascript.js"></script>
	<script src="/scripts/highlight.js"></script>


	<!-- Intercom -->
	<script>
	window.intercomSettings = { app_id: 'ytqx30hx' };
	(function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',intercomSettings);}else{var d=document;var i=function(){i.c(arguments)};i.q=[];i.c=function(args){i.q.push(args)};w.Intercom=i;function l(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/ytqx30hx';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);}if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})()
	</script>

	<!-- Analytics -->
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-37033501-2', 'auto');
	ga('send', 'pageview');
	</script>

	<!-- Inspectlet -->
	<script id="inspectletjs">
	window.__insp = window.__insp || [];
	__insp.push(['wid', 1029478452]);
	(function() {
		function ldinsp(){var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); };
		document.readyState != "complete" ? (window.attachEvent ? window.attachEvent('onload', ldinsp) : window.addEventListener('load', ldinsp, false)) : ldinsp();
	})();
	</script>
</body>
</html>